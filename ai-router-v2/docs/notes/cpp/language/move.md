---
title: move 语义
author: zfan
createTime: 2025/04/11 22:07:39
permalink: /cpp/language/move/
tags:
  - cpp
---

## 一. Value Category

- 纯右值

包含字面值: `1, 2, true`, 表达式: `a + b`, 以及函数返回的非引用对象:

```cpp
A func() {
  A a;
  return a;
}
```

- 将亡值

返回 `T&&` 的函数调用

```cpp
A&& func() { return A(); }
```

转换为`T&&` 的类型转换表达式

```cpp
static_cast<T&&>(t);
```

- `std::move(t)` : 将`t` 转换为右值

这里要区分值类型type和值类别value category

type: 就是int之类的变量或者表达式的静态属性, 也包括左值引用`int&`和右值引用`int&&`

value category: 只有三种, 左值, 纯右值, 将亡值

那么右值引用其实就是对右值的引用，给右值一个续命的“引用”，使得它不会立刻被析构, 是对应给右值的一种静态类型

这里有三条准则:

- 左值引用(`T&`): 只能绑定到​​左值​​(有持久身份的对象，如变量、返回左值引用的函数).

- ​​右值引用(`T&&`): 只能绑定到​​右值​​(临时对象、字面量、返回值的表达式).

- ​​const左值引用(`const T&`):可以绑定到​​左值或右值​​，因为const承诺不会修改对象.

并非带有`&&`的type就是右值引用, 这里要区分右值引用和通用引用, 通用引用会进行类型推导, 从而变为右值引用或者左值引用, 例如`T&& x`以及`auto&&`, 在发生类型推导的前提下, 我们传入的x就可以根据传入类型来判断

## 二. 为什么需要move

move将当前的值转化为将亡值，然后进行移动构造，避免了拷贝构造带来的性能开销.

## 三. 其他

1. 万能引用

2. 引用折叠

3. 完美转发
